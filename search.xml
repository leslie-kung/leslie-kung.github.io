<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python返回每个月最大天数</title>
    <url>/python/python%E8%BF%94%E5%9B%9E%E6%AF%8F%E4%B8%AA%E6%9C%88%E6%9C%80%E5%A4%A7%E5%A4%A9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="python返回过去时间里的每月最大天数"><a href="#python返回过去时间里的每月最大天数" class="headerlink" title="python返回过去时间里的每月最大天数"></a>python返回过去时间里的每月最大天数</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_list</span><span class="params">(num=<span class="number">1</span>)</span>:</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    year = now.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">    mon = now.strftime(<span class="string">'%m'</span>)</span><br><span class="line">    day = now.strftime(<span class="string">'%d'</span>)</span><br><span class="line">    date_list = []</span><br><span class="line">    date_list.append([day, mon, year])</span><br><span class="line">    temp = now</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num):</span><br><span class="line">        last_mon_day = temp - datetime.timedelta(days=temp.day)</span><br><span class="line">        last_day = last_mon_day.strftime(<span class="string">'%d'</span>)</span><br><span class="line">        mon = last_mon_day.strftime(<span class="string">'%m'</span>)</span><br><span class="line">        year = last_mon_day.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">        date_list.append([last_day, mon, year])</span><br><span class="line">        temp = last_mon_day</span><br><span class="line">    <span class="keyword">return</span> date_list</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回过去一年每个月的时间</span></span><br><span class="line">date_list = get_date_list(<span class="number">12</span>)</span><br><span class="line">print(date_list)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="string">'22'</span>, <span class="string">'06'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'05'</span>, <span class="string">'2018'</span>], [<span class="string">'30'</span>, <span class="string">'04'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'03'</span>, <span class="string">'2018'</span>], [<span class="string">'28'</span>, <span class="string">'02'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'01'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'12'</span>, <span class="string">'2017'</span>], [<span class="string">'30'</span>, <span class="string">'11'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'10'</span>, <span class="string">'2017'</span>], [<span class="string">'30'</span>, <span class="string">'09'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'08'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'07'</span>, <span class="string">'2017'</span>]]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中元素替换</title>
    <url>/python/python%E4%B8%AD%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="python中元素进行替换有很多方法，下面是我学习中的一些总结"><a href="#python中元素进行替换有很多方法，下面是我学习中的一些总结" class="headerlink" title="python中元素进行替换有很多方法，下面是我学习中的一些总结"></a>python中元素进行替换有很多方法，下面是我学习中的一些总结</h2><h3 id="1、字符串替换str-replace-方法"><a href="#1、字符串替换str-replace-方法" class="headerlink" title="1、字符串替换str.replace()方法"></a>1、字符串替换str.replace()方法</h3><p>python中的replace()方法是把字符串中的old字符串替换成new的字符串，如果指定替换次数max,则按照替换次数进行替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.replace(old,new,count=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>old：字符串替换前的字符<br>new：字符串替换后的字符<br>count：替换的次数，默认为0，不填表示全局替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! I love python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>)  <span class="comment"># 表示全局替换</span></span><br><span class="line"><span class="string">'he@@o wor@d! I @ove python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>,<span class="number">2</span>)  <span class="comment"># 替换指定次数</span></span><br><span class="line"><span class="string">'he@@o world! I love python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>,<span class="number">2</span>).replace(<span class="string">"o"</span>,<span class="string">"$"</span>)  <span class="comment"># 多个字符替换可以进行链式调用replace()方法</span></span><br><span class="line"><span class="string">'he@@$ w$rld! I l$ve pyth$n!'</span></span><br></pre></td></tr></table></figure>

<h3 id="2、正则表达式中的sub-和subn-方法"><a href="#2、正则表达式中的sub-和subn-方法" class="headerlink" title="2、正则表达式中的sub()和subn()方法"></a>2、正则表达式中的sub()和subn()方法</h3><p>sub(pattern, repl, string)<br>其中pattern表示原字符串中的字符，repl表示需要替换成的字符，string表示需要替换的字符串；<br>subn()和sub()的区别在于subn()返回的一个包含新字符串和替换次数的二元组；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! I love python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">"hello"</span>,<span class="string">"nihao"</span>,str)  </span><br><span class="line"><span class="string">'nihao world! I love python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.subn(<span class="string">"l"</span>,<span class="string">"*"</span>,str)</span><br><span class="line">(<span class="string">'he**o wor*d! I *ove python!'</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、如果同时处理多个字符串的替换，此时可以使用string的maketrans-和translate-方法"><a href="#3、如果同时处理多个字符串的替换，此时可以使用string的maketrans-和translate-方法" class="headerlink" title="3、如果同时处理多个字符串的替换，此时可以使用string的maketrans()和translate()方法"></a>3、如果同时处理多个字符串的替换，此时可以使用string的maketrans()和translate()方法</h3><p>maketrans()方法用来生成字符映射表，而translate()方法则按映射表中定义的对应关系转换并替换其中的字符，用这两种方法可以同时处理多个不同的字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = <span class="string">''</span>.maketrans(<span class="string">"abcdefghij"</span>,<span class="string">"1234567890"</span>)  <span class="comment"># 创建映射表，注意字符串的长度要一致，达到一一对应的目的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! i love python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.translate(table)  <span class="comment"># 按照关系表将sting中的字符逐个进行替换</span></span><br><span class="line"><span class="string">'85llo worl4! 9 lov5 pyt8on'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4、对列表里的元素进行替换，可以使用列表解析的方法"><a href="#4、对列表里的元素进行替换，可以使用列表解析的方法" class="headerlink" title="4、对列表里的元素进行替换，可以使用列表解析的方法"></a>4、对列表里的元素进行替换，可以使用列表解析的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [<span class="number">5</span> <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-1、批量进行替换"><a href="#4-1、批量进行替换" class="headerlink" title="4.1、批量进行替换"></a>4.1、批量进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = [<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [<span class="string">"a"</span> <span class="keyword">if</span> x <span class="keyword">in</span> pattern <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-2、根据字典的映射进行替换"><a href="#4-2、根据字典的映射进行替换" class="headerlink" title="4.2、根据字典的映射进行替换"></a>4.2、根据字典的映射进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="number">1</span>:<span class="string">"apple"</span>, <span class="number">3</span>:<span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [dict[x] <span class="keyword">if</span> x <span class="keyword">in</span> dict <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="string">'apple'</span>, <span class="number">2</span>, <span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io-StringIO对象。"><a href="#5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io-StringIO对象。" class="headerlink" title="5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io.StringIO对象。"></a>5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io.StringIO对象。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world!"</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str = StringIO(str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str</span><br><span class="line">&lt;_io.StringIO object at <span class="number">0x7fa1e61addc8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.tell()  <span class="comment"># 返回当前的位置</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.read()  <span class="comment"># 从当前位置开始读取字符串</span></span><br><span class="line"><span class="string">'hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.getvalue()  <span class="comment"># 返回字符串的全部内容</span></span><br><span class="line"><span class="string">'hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.seek(<span class="number">6</span>)  <span class="comment"># 定义开始修改的位置</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.write(<span class="string">"china"</span>)  <span class="comment"># 修改字符串</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.read()</span><br><span class="line"><span class="string">'!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.getvalue()  <span class="comment"># 获取修改后的字符串全部内容</span></span><br><span class="line"><span class="string">'hello china!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.tell() </span><br><span class="line"><span class="number">12</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中arrow库的使用</title>
    <url>/python/python%E4%B8%ADarrow%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p> Arrow是一个Python库，为创建，操作，格式化和转换日期，时间和时间戳提供了一种明智的，人性化的方法。 它实现和更新日期时间类型，填补功能上的空白，并提供支持许多常见创建场景的智能模块API。 简而言之，它可以帮助您使用更少的进口和更少的代码来处理日期和时间。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> arrow</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="简单开始"><a href="#简单开始" class="headerlink" title="简单开始"></a>简单开始</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> arrow</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.utcnow()  <span class="comment"># 获取世界标准时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T09:<span class="number">37</span>:<span class="number">28.989983</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.now()  <span class="comment"># 获取本地时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">40</span>:<span class="number">19.019529</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.now(<span class="string">'US/Pacific'</span>)  <span class="comment"># 获取指定时区的时间</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T02:<span class="number">41</span>:<span class="number">54.815029</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">44</span>:<span class="number">43.519166</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.year  <span class="comment"># 当前年</span></span><br><span class="line"><span class="number">2018</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.month  <span class="comment"># 当前月份</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.day  <span class="comment"># 当前天</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.hour  <span class="comment"># 当前第几个小时</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.minute  <span class="comment"># 当前多少分钟</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.second  <span class="comment"># 当前多少秒</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.timestamp  <span class="comment"># 获取时间戳</span></span><br><span class="line"><span class="number">1528364683</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.float_timestamp  <span class="comment"># 浮点数时间戳</span></span><br><span class="line"><span class="number">1528364683.519166</span></span><br></pre></td></tr></table></figure>

<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">59</span>:<span class="number">36.917894</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.format()</span><br><span class="line"><span class="string">'2018-06-07 17:59:36+08:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.format(<span class="string">'YYYY-MM-DD HH:mm:ss ZZ'</span>)</span><br><span class="line"><span class="string">'2018-06-07 17:59:36 +08:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ctime()  <span class="comment"># 返回日期和时间的ctime格式化表示。</span></span><br><span class="line"><span class="string">'Thu Jun  7 17:59:36 2018'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.weekday()  <span class="comment"># 以整数形式返回星期几（0-6）</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.isoweekday()  <span class="comment"># 以整数形式返回一周中的ISO日（1-7）</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.isocalendar()  <span class="comment"># 返回3元组（ISO年，ISO周数，ISO工作日）</span></span><br><span class="line">(<span class="number">2018</span>, <span class="number">23</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.toordinal()  <span class="comment"># 返回日期的格雷戈里序数</span></span><br><span class="line"><span class="number">736852</span></span><br></pre></td></tr></table></figure>

<h3 id="从string中解析时间对象"><a href="#从string中解析时间对象" class="headerlink" title="从string中解析时间对象"></a>从string中解析时间对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(<span class="string">'2018-06-07 18:52:45'</span>, <span class="string">'YYYY-MM-DD HH:mm:ss'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T18:<span class="number">52</span>:<span class="number">45</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'June was born in May 1980'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(str,<span class="string">'MMMM YYYY'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">1980</span><span class="number">-05</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="解析的格式化参考：http-arrow-readthedocs-io-en-latest-tokens"><a href="#解析的格式化参考：http-arrow-readthedocs-io-en-latest-tokens" class="headerlink" title="解析的格式化参考：http://arrow.readthedocs.io/en/latest/#tokens"></a>解析的格式化参考：<a href="http://arrow.readthedocs.io/en/latest/#tokens" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/#tokens</a></h3><h3 id="时间的替换和偏移"><a href="#时间的替换和偏移" class="headerlink" title="时间的替换和偏移"></a>时间的替换和偏移</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.replace(hour=<span class="number">20</span>,minute=<span class="number">00</span>)  <span class="comment"># 替换时间</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T20:<span class="number">00</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.replace(tzinfo=<span class="string">'US/Pacific'</span>)  <span class="comment"># 替换时区</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T19:<span class="number">04</span>:<span class="number">50.245201</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.shift(days=+<span class="number">3</span>)  <span class="comment"># 往后偏移三天</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-10</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.shift(days=<span class="number">-3</span>)  <span class="comment"># 往前偏移三天</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-04</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="按名称或tzinfo转换为时区"><a href="#按名称或tzinfo转换为时区" class="headerlink" title="按名称或tzinfo转换为时区"></a>按名称或tzinfo转换为时区</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">16</span>:<span class="number">51.695083</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.to(<span class="string">'US/Pacific'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T04:<span class="number">16</span>:<span class="number">51.695083</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="更人性化的设计"><a href="#更人性化的设计" class="headerlink" title="更人性化的设计"></a>更人性化的设计</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>past = arrow.utcnow().shift(hours=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>past</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T10:<span class="number">24</span>:<span class="number">19.968351</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>past.humanize()</span><br><span class="line"><span class="string">'an hour ago'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>present = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future = present.shift(hours=+<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T13:<span class="number">25</span>:<span class="number">57.160630</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future.humanize()</span><br><span class="line"><span class="string">'in 2 hours'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future.humanize(a,locale=<span class="string">'ru'</span>)  <span class="comment"># 支持更多的语言环境</span></span><br><span class="line"><span class="string">'через 3 часа'</span></span><br></pre></td></tr></table></figure>

<h3 id="获取任意时间单位的时间跨度"><a href="#获取任意时间单位的时间跨度" class="headerlink" title="获取任意时间单位的时间跨度"></a>获取任意时间单位的时间跨度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'hour'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'year'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-01</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-12</span><span class="number">-31</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'month'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-30</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'day'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="只得到任意单位时间中的最大值或最小值"><a href="#只得到任意单位时间中的最大值或最小值" class="headerlink" title="只得到任意单位时间中的最大值或最小值"></a>只得到任意单位时间中的最大值或最小值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().floor(<span class="string">'hour'</span>)  </span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().ceil(<span class="string">'hour'</span>)  </span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().floor(<span class="string">'day'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().ceil(<span class="string">'day'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="表示特定于语言环境的数据和功能的类"><a href="#表示特定于语言环境的数据和功能的类" class="headerlink" title="表示特定于语言环境的数据和功能的类"></a>表示特定于语言环境的数据和功能的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arrow.locales.Locale</span><br></pre></td></tr></table></figure>

<h2 id="arrow库的官方文档：http-arrow-readthedocs-io-en-latest"><a href="#arrow库的官方文档：http-arrow-readthedocs-io-en-latest" class="headerlink" title="arrow库的官方文档：http://arrow.readthedocs.io/en/latest/"></a>arrow库的官方文档：<a href="http://arrow.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/</a></h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中random库使用</title>
    <url>/python/python%E4%B8%ADrandom%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、random-random-生成一个随机的浮点数，范围在0-0-0-1之间；"><a href="#1、random-random-生成一个随机的浮点数，范围在0-0-0-1之间；" class="headerlink" title="1、random.random() 生成一个随机的浮点数，范围在0.0~0.1之间；"></a>1、random.random() 生成一个随机的浮点数，范围在0.0~0.1之间；</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.random()</span><br><span class="line">print(num)  <span class="comment"># num=0.4329135788510704</span></span><br></pre></td></tr></table></figure>
<h3 id="2、random-uniform-函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；"><a href="#2、random-uniform-函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；" class="headerlink" title="2、random.uniform() 函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；"></a>2、random.uniform() 函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；</h3><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.uniform(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(num)  <span class="comment"># num=1.9499995621894857</span></span><br></pre></td></tr></table></figure>
<h3 id="3、random-randint-随机生成一个整数int类型-可以指定这个整数的范围，同样有上限和下限"><a href="#3、random-randint-随机生成一个整数int类型-可以指定这个整数的范围，同样有上限和下限" class="headerlink" title="3、random.randint() 随机生成一个整数int类型,可以指定这个整数的范围，同样有上限和下限"></a>3、random.randint() 随机生成一个整数int类型,可以指定这个整数的范围，同样有上限和下限</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">print(num)  <span class="comment"># num=2</span></span><br></pre></td></tr></table></figure>
<h3 id="4、random-choice-可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等"><a href="#4、random-choice-可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等" class="headerlink" title="4、random.choice() 可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等"></a>4、random.choice() 可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">num = random.choice(list)</span><br><span class="line">print(num)  <span class="comment"># num=5</span></span><br></pre></td></tr></table></figure>
<h3 id="5、random-shuffle-随机打乱一个序列"><a href="#5、random-shuffle-随机打乱一个序列" class="headerlink" title="5、random.shuffle() 随机打乱一个序列"></a>5、random.shuffle() 随机打乱一个序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(list)  <span class="comment"># list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">random.shuffle(list)</span><br><span class="line">print(list)  <span class="comment"># list=[1, 5, 4, 2, 0, 6, 9, 8, 3, 7]</span></span><br></pre></td></tr></table></figure>
<h3 id="6、random-sample-可以从指定的序列中，随机截取指定长度的片段，不做原地修改"><a href="#6、random-sample-可以从指定的序列中，随机截取指定长度的片段，不做原地修改" class="headerlink" title="6、random.sample() 可以从指定的序列中，随机截取指定长度的片段，不做原地修改"></a>6、random.sample() 可以从指定的序列中，随机截取指定长度的片段，不做原地修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">new_list = random.sample(list, <span class="number">5</span>)  <span class="comment"># 第一个参数要截取的对象，第二个参数是截取的长度</span></span><br><span class="line">print(new_list)  <span class="comment"># [7, 9, 0, 8, 1]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理简单验证码</title>
    <url>/python/python%E5%A4%84%E7%90%86%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h4 id="利用python对简单的验证码进行处理"><a href="#利用python对简单的验证码进行处理" class="headerlink" title="利用python对简单的验证码进行处理"></a>利用python对简单的验证码进行处理</h4><p>验证码如下所示：<br><img src="/image/code/code.png" alt="这里写图片描述"><br>首先导入我们需要的包文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_lowercase</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy</span><br></pre></td></tr></table></figure>
<p>将验证码进行切分，其中进行切分的坐标可以自行调整最佳；Image模块的convert()函数，用于不同模式图像之间的转换。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div_im</span><span class="params">(im_name)</span>:</span></span><br><span class="line">    im = Image.open(im_name).convert(<span class="string">'L'</span>)   <span class="comment"># 转换为灰度图像返回</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">''</span>.join(random.sample(ascii_lowercase, <span class="number">10</span>))  <span class="comment"># 随机序列化一个字符串</span></span><br><span class="line">    regions = [(<span class="number">8</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">26</span>), (<span class="number">20</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">26</span>), (<span class="number">32</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">26</span>), (<span class="number">44</span>, <span class="number">6</span>, <span class="number">56</span>, <span class="number">26</span>)]   <span class="comment"># 定义切分坐标</span></span><br><span class="line">    arr = list()</span><br><span class="line">    <span class="keyword">for</span> i, region <span class="keyword">in</span> enumerate(regions):</span><br><span class="line">        im2 = im.crop(region)   <span class="comment"># 将验证码按坐标进行切分</span></span><br><span class="line">        f_name = <span class="string">'&#123;&#125;_&#123;&#125;.jpg'</span>.format(name, i)</span><br><span class="line">        im2.save(f_name)</span><br><span class="line">        arr.append(f_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>切分后返回的图片为：<br><img src="/image/code/code1.jpg" alt="这里写图片描述"> <img src="/image/code/code2.jpg" alt="这里写图片描述"> <img src="/image/code/code3.jpg" alt="这里写图片描述"> <img src="/image/code/code4.jpg" alt="这里写图片描述"></p>
<p>将图片进行二值化处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_im_to_array</span><span class="params">(im_name)</span>:</span></span><br><span class="line">    im = Image.open(im_name).convert(<span class="string">'L'</span>)</span><br><span class="line">    a = numpy.array(im)</span><br><span class="line">    a = numpy.array([[<span class="number">0</span> <span class="keyword">if</span> j &lt; <span class="number">5</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> i] <span class="keyword">for</span> i <span class="keyword">in</span> a])  <span class="comment"># 数字5是自己调整的阈值</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>样本集标注：采集100张验证码图片进行切分，人为进行标注0~9；<br><img src="/image/code/test1.png" alt="这里写图片描述"><br><img src="/image/code/test2.png" alt="这里写图片描述"></p>
<p>最后就是进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec</span><span class="params">(f_name)</span>:</span></span><br><span class="line">    a = convert_im_to_array(f_name)  <span class="comment"># 测试图片的二值化数组</span></span><br><span class="line">    min_i = <span class="number">-1</span></span><br><span class="line">    min_v = <span class="number">10000000</span>  <span class="comment"># 选择一个较大的数即可</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = <span class="string">'sample_im/&#123;&#125;'</span>.format(i)  <span class="comment"># 样本集路径0~9</span></span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> os.listdir(p):</span><br><span class="line">            b = convert_im_to_array(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(p, im))  <span class="comment"># 样本集图片的二值化数组</span></span><br><span class="line">            tmp = sum(sum((a - b)**<span class="number">2</span>))  </span><br><span class="line">            print(tmp)</span><br><span class="line">            <span class="keyword">if</span> tmp &lt; min_v:</span><br><span class="line">                min_v = tmp</span><br><span class="line">                min_i = i</span><br><span class="line">            print(<span class="string">"min_v的值："</span>,min_v)</span><br><span class="line">        print(<span class="string">"min_i的值："</span>,min_i)</span><br><span class="line">    <span class="keyword">return</span> min_i  <span class="comment"># 返回图片中的数字</span></span><br></pre></td></tr></table></figure>
<p>最后可以进行多次测试比较识别的准确率。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python进行excel转json</title>
    <url>/python/python%E8%BF%9B%E8%A1%8Cexcel%E8%BD%ACjson/</url>
    <content><![CDATA[<h2 id="使用python进行excel转json文件"><a href="#使用python进行excel转json文件" class="headerlink" title="使用python进行excel转json文件"></a>使用python进行excel转json文件</h2><h3 id="1、首先导入我们需要用到的库"><a href="#1、首先导入我们需要用到的库" class="headerlink" title="1、首先导入我们需要用到的库"></a>1、首先导入我们需要用到的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2、具体代码如下："><a href="#2、具体代码如下：" class="headerlink" title="2、具体代码如下："></a>2、具体代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Excel_to_json</span><span class="params">(file)</span>:</span></span><br><span class="line">    wb = xlrd.open_workbook(file)</span><br><span class="line"></span><br><span class="line">    convert_list = []</span><br><span class="line">    sh = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    title = sh.row_values(<span class="number">0</span>)  <span class="comment"># 表头，json文件的key</span></span><br><span class="line">    print(title)</span><br><span class="line">    <span class="keyword">for</span> rownum <span class="keyword">in</span> range(<span class="number">1</span>, sh.nrows):</span><br><span class="line">        rowvalue = sh.row_values(rownum)</span><br><span class="line">        single = OrderedDict()  <span class="comment"># 有序字典</span></span><br><span class="line">        <span class="keyword">for</span> colnum <span class="keyword">in</span> range(<span class="number">0</span>, len(rowvalue)):</span><br><span class="line">            print(<span class="string">"key:&#123;0&#125;, value:&#123;1&#125;"</span>.format(title[colnum], rowvalue[colnum]))</span><br><span class="line">            single[title[colnum]] = rowvalue[colnum]</span><br><span class="line">        convert_list.append(single)</span><br><span class="line"></span><br><span class="line">    j = json.dumps(convert_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"file.json"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(j)</span><br></pre></td></tr></table></figure>
<h2 id="使用python进行json转csv文件"><a href="#使用python进行json转csv文件" class="headerlink" title="使用python进行json转csv文件"></a>使用python进行json转csv文件</h2><h3 id="1、同样，我们先导入需要的库"><a href="#1、同样，我们先导入需要的库" class="headerlink" title="1、同样，我们先导入需要的库"></a>1、同样，我们先导入需要的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<h3 id="2、代码如下："><a href="#2、代码如下：" class="headerlink" title="2、代码如下："></a>2、代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_to_csv</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(path + <span class="string">'.json'</span>, <span class="string">"r"</span>) <span class="keyword">as</span>  f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    jsonData = json.loads(data)</span><br><span class="line"></span><br><span class="line">    csvfile = open(path + <span class="string">".csv"</span>, <span class="string">"w"</span>, newline=<span class="string">''</span>)</span><br><span class="line">    keys_write = <span class="literal">True</span></span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    print(jsonData)</span><br><span class="line">    <span class="keyword">for</span> dic <span class="keyword">in</span> jsonData:</span><br><span class="line">        <span class="keyword">if</span> keys_write:</span><br><span class="line">            keys = list(dic.keys())</span><br><span class="line">            print(keys)</span><br><span class="line">            writer.writerow(keys)</span><br><span class="line">            keys_write = <span class="literal">False</span></span><br><span class="line">        writer.writerow(list(dic.values()))</span><br><span class="line">        print(list(dic.values()))</span><br><span class="line">    csvfile.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    path = <span class="string">"file"</span>  <span class="comment"># 文件的路径</span></span><br><span class="line">    json_to_csv(path)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python字典多次嵌套</title>
    <url>/python/python%E5%AD%97%E5%85%B8%E5%A4%9A%E6%AC%A1%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h2 id="python实现字典多层嵌套"><a href="#python实现字典多层嵌套" class="headerlink" title="python实现字典多层嵌套"></a>python实现字典多层嵌套</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于字典</span></span><br><span class="line">dict1 = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c.1"</span>:<span class="number">3</span>, <span class="string">"c.2"</span>:<span class="number">4</span>, <span class="string">"d.5.2"</span>:<span class="number">5</span>, <span class="string">"d.5.3"</span>:<span class="number">6</span>, <span class="string">"d.4.1"</span>:<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将其实现多次嵌套效果</span></span><br><span class="line">dict2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: &#123;<span class="string">'1'</span>: <span class="number">3</span>, <span class="string">'2'</span>: <span class="number">4</span>&#125;, </span><br><span class="line">        <span class="string">'d'</span>: &#123;<span class="string">'5'</span>: &#123;<span class="string">'2'</span>: <span class="number">5</span>, <span class="string">'3'</span>: <span class="number">6</span>&#125;, <span class="string">'4'</span>: &#123;<span class="string">'1'</span>: <span class="number">7</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c.1"</span>:<span class="number">3</span>, <span class="string">"c.2"</span>:<span class="number">4</span>, <span class="string">"d.5.2"</span>:<span class="number">5</span>, <span class="string">"d.5.3"</span>:<span class="number">6</span>, <span class="string">"d.4.1"</span>:<span class="number">7</span>&#125;</span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(d1)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> d1.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> key:</span><br><span class="line">            parts = key.split(<span class="string">'.'</span>)</span><br><span class="line">            par = d2</span><br><span class="line">            key = parts.pop(<span class="number">0</span>)</span><br><span class="line">            print(<span class="string">'=========='</span>, key)</span><br><span class="line">            <span class="keyword">while</span> parts:</span><br><span class="line">                par = par.setdefault(key, &#123;&#125;)</span><br><span class="line">                print(par)</span><br><span class="line">                key = parts.pop(<span class="number">0</span>)</span><br><span class="line">            par[key] = value</span><br><span class="line">            print(par)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        d2[key] = value</span><br><span class="line"></span><br><span class="line">fun(d1)</span><br><span class="line">print(d2)</span><br></pre></td></tr></table></figure>

<h3 id="其中用到了字典的setdefault方法"><a href="#其中用到了字典的setdefault方法" class="headerlink" title="其中用到了字典的setdefault方法"></a>其中用到了字典的setdefault方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict.setdefault(key,default=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>如果键不存在于字典中，将会添加新的键，并将值设置为默认值；如果字典中包含该给定的键，则返回该键对应的值，否则返回该键设置的默认值。</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>dict.get(key,default=None)<br>get方法返回给定键的值，如果键不可用返回默认值；</p>
<h3 id="collection-defaultdict"><a href="#collection-defaultdict" class="headerlink" title="collection defaultdict"></a>collection defaultdict</h3><p>defaultdict()返回一个字典，自动给每一个键赋一个初始值</p>
<p><em>参考链接地址：<a href="https://blog.csdn.net/whgyxy/article/details/72458000" target="_blank" rel="noopener">https://blog.csdn.net/whgyxy/article/details/72458000</a></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中闭包和装饰器</title>
    <url>/python/python%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><p>   <em>闭包</em> 是引用了变量的函数，这个被引用的自由变量将和这个函数一同存在，即使离开了创造这个变量的环境也不例外。所以，<em>闭包</em> 是由函数和与其相关的引用环境组合而成的实体。简单来说，<em>闭包</em> 就是数据和功能的结合。</p>
<a id="more"></a>
<h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><p> <strong>优点：</strong> 可以提高代码的可复用性<br> <strong>缺点：</strong> 由于闭包是引用了外部函数的局部变量，导致外部函数的局部变量没有及时释放，消耗内存。</p>
<h2 id="2-装饰器"><a href="#2-装饰器" class="headerlink" title="2.装饰器"></a>2.装饰器</h2><h3 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h3><p>装饰器本质上也还是一个python函数，它可以让其他函数在不需要的做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。装饰器的应用场景主要是一些有切面需求的场景，例如：插入日志，性能测试，事务处理，缓存，权限校验等。通过装饰器，我们可以抽离大量与函数功能本身无关的雷同代码并重复应用。</p>
<h3 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h3><ul>
<li>引入日志</li>
<li>函数执行时间统计</li>
<li>执行函数前的预备处理</li>
<li>执行函数后的清理功能</li>
<li>权限校验等场景</li>
<li>缓存</li>
</ul>
<h3 id="一个函数同时被多个装饰器装饰的执行顺序"><a href="#一个函数同时被多个装饰器装饰的执行顺序" class="headerlink" title="一个函数同时被多个装饰器装饰的执行顺序"></a>一个函数同时被多个装饰器装饰的执行顺序</h3><p> 一个函数如果同时被多个装饰器装饰，由紧靠函数的装饰器先对函数进行装饰，然后返回的结果在给外层的装饰器去执行装饰，依次类推直到所有装饰器都装饰完成，最后会得到一个函数，在执行这个函数的时候，会先执行最外层装饰器的内容，在执行里面装饰器的内容。这个过程有点像我们给一个精美的物品进行一层一层的包装，在包装的时候是从最里面一层层往往包装，拆开的时候又是从外面一层层的拆开。</p>
<h3 id="对比函数、闭包、对象在作为实参时的区别"><a href="#对比函数、闭包、对象在作为实参时的区别" class="headerlink" title="对比函数、闭包、对象在作为实参时的区别"></a>对比函数、闭包、对象在作为实参时的区别</h3><p><strong>函数作为实参</strong>  如果没有()会作为一个功能传入到另一个函数，如果有()，则会传入这个函数的执行结果即返回值<br><strong>闭包作为实参</strong>  会传入较为复杂的功能和数据<br><strong>对象作为实参</strong>  会传入最为复杂的功能和数据，但是对象占用的空间比较大，传递的是很多的功能和数据</p>
<h3 id="通用的装饰器"><a href="#通用的装饰器" class="headerlink" title="通用的装饰器"></a>通用的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_fun</span><span class="params">(fun)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">call_fun</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"----这是前面的功能---权限验证---"</span>)</span><br><span class="line">		ret = fun(*args, **kwargs)</span><br><span class="line">		print(<span class="string">"----这是后面的功能---log日志功能---"</span>)</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	<span class="keyword">return</span> call_fun</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI1MjI0NjA4NDQ2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之copy</title>
    <url>/python/python%E4%B9%8Bcopy/</url>
    <content><![CDATA[<h2 id="Python中的引用、浅拷贝和深拷贝"><a href="#Python中的引用、浅拷贝和深拷贝" class="headerlink" title="Python中的引用、浅拷贝和深拷贝"></a>Python中的引用、浅拷贝和深拷贝</h2><p>在python中，有一句话：<em>一切皆为对象，一切皆为对象的引用</em>，所以<br>只要记住这句话就很容易清楚python中的引用、浅拷贝和深拷贝了。</p>
<h3 id="1、引用"><a href="#1、引用" class="headerlink" title="1、引用"></a>1、引用</h3><p>python中的引用是经常使用的，python的引用可以节省内存，加快速度，因为它不需要开辟内存空间。例如：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这表示让 a 这个变量去指向一个地址，这个地址保存着数据为 1，让变量 b 也去指向这个地址，那么通过 b 我们一样可以找到数据 1，通过地址的指向来<br>来查找到数据，这就是python中的引用；</p>
<h3 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h3><p>浅拷贝 copy.copy()<br>浅拷贝保存的是数据的地址，不保存内容，浅拷贝是需要开辟单独的内存空间来存储地址的，它不能保证<br>数据的独立性。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="comment"># a 的值[1, 2, 3]</span></span><br><span class="line"><span class="comment"># b 的值[1, 2, 3]</span></span><br><span class="line">id(a)  <span class="comment"># 1397274473</span></span><br><span class="line">id(b)  <span class="comment"># 1397274545</span></span><br></pre></td></tr></table></figure>
<p>可以看出 b 的数据和 a 的数据一样，但是 b 的地址和 a 的地址不相同，而且 b 的地址里保存的是列表里元素 1， 2， 3 的地址，b 通过保存的地址信息来获取数据1, 2, 3 可以通过下面的例子得出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id(a)  <span class="comment"># 1397274473</span></span><br><span class="line">id(b)  <span class="comment"># 1397274545</span></span><br><span class="line">id(a[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br><span class="line">id(b[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">id(a[<span class="number">0</span>])  <span class="comment"># 20705456</span></span><br><span class="line">id(b[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br></pre></td></tr></table></figure>
<p>可以看出列表a 和列表 b 里面的元素 1 都指向着同一个地址，当列表 a 的第一个元素的值变为8时，即指向一个新的保存数据为 8 的地址时，列表b 的第一个元素仍然保存的是元素 1 的地址，此时可以看出，浅拷贝只是把数据的地址保存了，并没有保存数据本身，当列表中如果有元素为可变的列表或字典类时，因为拷贝的是列表或字典所对应的地址，如果列表或字典中有元素发生改变，则浅拷贝的列表也会跟着改变，不能保证数据的独立性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">d = copy.copy(c)</span><br><span class="line"><span class="comment"># c=[1, 2, [3, 4]]</span></span><br><span class="line"><span class="comment"># d=[1, 2, [3, 4]]</span></span><br><span class="line">id(c)  <span class="comment"># 13972747060</span></span><br><span class="line">id(d)  <span class="comment"># 13972745446</span></span><br><span class="line">id(c[<span class="number">2</span>][<span class="number">0</span>])  <span class="comment"># 20705576</span></span><br><span class="line">id(d[<span class="number">2</span>][<span class="number">0</span>])  <span class="comment"># 20705576</span></span><br><span class="line"></span><br><span class="line">c[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># c=[1, 2, [3, 4, 5]]</span></span><br><span class="line">id(c)  <span class="comment"># 13972747060</span></span><br><span class="line">d <span class="comment"># d=[1, 2, [3, 4, 5]]</span></span><br><span class="line">id(d)  <span class="comment"># 13972745446</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">a <span class="comment"># [1, 2, 3]</span></span><br><span class="line">b <span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h3><p>深拷贝copy.deepcopy()<br>python中，深拷贝在浅拷贝的基础上更进一步，深拷贝保存的是数据的本身，一旦进行深拷贝，则拷贝后的内容不仅和原本的内容完全一样，而且跟原来的没有任何联系，充分保证了数据的独立性。<br>深拷贝相当于在内存中开辟了一片新的内存，不再用来保存数据的地址，而是用新的地址来保存相同的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">a  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line">b  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line">a  <span class="comment"># [1, 2, [3, 4, 5]]</span></span><br><span class="line">b  <span class="comment"># [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure>
<p>可以看出深拷贝是把列表里的数据保存了，和浅拷贝不同，当列表 a 发生改变时，列表 b 并不会跟着改变，这样充分体现了深拷贝可以保证数据的独立性。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python版布隆过滤器</title>
    <url>/python/python%E7%89%88%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="首先导包"><a href="#首先导包" class="headerlink" title="首先导包"></a>首先导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-conding: utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> six</span><br><span class="line"><span class="keyword">import</span> redis</span><br></pre></td></tr></table></figure>

<h3 id="定义哈希Map类"><a href="#定义哈希Map类" class="headerlink" title="定义哈希Map类"></a>定义哈希Map类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleHash</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""根据提供的原始数据，和预定义的多个salt，生成多个hash值"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, salts, hash_func_name=<span class="string">'md5'</span>)</span>:</span></span><br><span class="line">        self.hash_func = getattr(hashlib, hash_func_name)</span><br><span class="line">        <span class="keyword">if</span> len(salts) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"please provide more than 3 element(salt) in the salts"</span>)</span><br><span class="line">        self.salts = salts</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_safe_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param data: 原始数据</span></span><br><span class="line"><span class="string">        :return: 处理成对应python版本可以被hash函数的update方法解析的数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> six.PY3:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">return</span> data.encode()</span><br><span class="line">            <span class="keyword">elif</span> isinstance(data, bytes):</span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"please provide a right str data"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, unicode):</span><br><span class="line">                <span class="keyword">return</span> data.encode()</span><br><span class="line">            <span class="keyword">elif</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span>  Exception(<span class="string">"please provide a right str data"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_hash_values</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""根据提供的原始数据, 返回多个hash函数值"""</span></span><br><span class="line">        hash_values = []</span><br><span class="line">        hash_obj = self.hash_func()</span><br><span class="line">        <span class="keyword">for</span> salt <span class="keyword">in</span> self.salts:</span><br><span class="line">            hash_obj.update(self._safe_data(data))</span><br><span class="line">            hash_obj.update(self._safe_data(salt))</span><br><span class="line">            ret = hash_obj.hexdigest()</span><br><span class="line">            hash_values.append(int(ret, <span class="number">16</span>))</span><br><span class="line">        <span class="keyword">return</span> hash_values</span><br></pre></td></tr></table></figure>

<h3 id="定义布隆过滤器"><a href="#定义布隆过滤器" class="headerlink" title="定义布隆过滤器"></a>定义布隆过滤器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""布隆过滤器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, salts, redis_host=<span class="string">"localhost"</span>, redis_port=<span class="number">6379</span>, redis_db=<span class="number">0</span>, redis_key=<span class="string">"bloomfilter"</span>)</span>:</span></span><br><span class="line">        self.redis_host = redis_host</span><br><span class="line">        self.redis_port = redis_port</span><br><span class="line">        self.redis_db = redis_db</span><br><span class="line">        self.redis_key = redis_key</span><br><span class="line">        self.client = self._get_redis_cli()</span><br><span class="line">        self.multiple_hash = MultipleHash(salts=salts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_redis_cli</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个redis连接对象"""</span></span><br><span class="line">        pool = redis.ConnectionPool(host=self.redis_host, port=self.redis_port, db=self.redis_db)</span><br><span class="line">        client = redis.StrictRedis(connection_pool=pool)</span><br><span class="line">        <span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        hash_values = self.multiple_hash.get_hash_values(data)</span><br><span class="line">        <span class="keyword">for</span> hash_value <span class="keyword">in</span> hash_values:</span><br><span class="line">            offset = self._get_offset(hash_value)</span><br><span class="line">            self.client.setbit(self.redis_key, offset, <span class="number">1</span>)  <span class="comment"># default 0, set 1 when match</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_offset</span><span class="params">(self, hash_value)</span>:</span></span><br><span class="line">        <span class="comment"># (2**9 * 2**20 * 2**3): the len of hash list 哈希表的长度</span></span><br><span class="line">        <span class="keyword">return</span> hash_value % (<span class="number">2</span>**<span class="number">9</span> * <span class="number">2</span>**<span class="number">20</span> * <span class="number">2</span>**<span class="number">3</span>)  <span class="comment"># Mb -&gt; bit</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_exists</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        hash_values = self.multiple_hash.get_hash_values(data)</span><br><span class="line">        <span class="keyword">for</span> hash_value <span class="keyword">in</span> hash_values:</span><br><span class="line">            offset = self._get_offset(hash_value)</span><br><span class="line">            v = self.client.getbit(self.redis_key, offset)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                self.save(data)  <span class="comment"># 如果不存在，保存数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="string">"asfdsafweafxc"</span>, <span class="string">"123"</span>, <span class="string">"123"</span>, <span class="string">"hello"</span>, <span class="string">"hello"</span>, <span class="string">'haha'</span>]</span><br><span class="line">    bm = BloomFilter(salts=[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>], redis_host=<span class="string">"10.0.12.191"</span>, redis_db=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bm.is_exists(d):</span><br><span class="line">            print(<span class="string">"mapping data success : %s"</span> % d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"find replace data : %s"</span> % d)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pep8的使用</title>
    <url>/python/pep8/</url>
    <content><![CDATA[<h2 id="1-介绍-Introduction"><a href="#1-介绍-Introduction" class="headerlink" title="1 介绍(Introduction)"></a>1 介绍(Introduction)</h2><p>本文档给出了包含主要Python发行版中的标准库的Python代码的编码约定。<br>随着时间的推移，随着更多的约定被识别，过去的约定被语言本身的变化所淘汰，这种风格指南也在不断发展。</p>
<a id="more"></a>
<h2 id="2-代码布局-Code-Lay-Out"><a href="#2-代码布局-Code-Lay-Out" class="headerlink" title="2 代码布局(Code Lay-Out)"></a>2 代码布局(Code Lay-Out)</h2><h3 id="2-1-缩进-Indentation"><a href="#2-1-缩进-Indentation" class="headerlink" title="2.1 缩进(Indentation)"></a>2.1 缩进(Indentation)</h3><p>每个缩进需要使用4个空格。</p>
<p>连续行所包装的元素应该要么采用Python隐式续行，即垂直对齐于圆括号、方括号和花括号，要么采用悬挂缩进。采用悬挂缩进时需考虑以下两点：第一行不应该包括参数，并且在续行中需要再缩进一级以便清楚表示。</p>
<p>正确的写法</p>
<pre><code># 同开始分界符(左括号)对齐
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 续行多缩进一级以同其他代码区别
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# 悬挂缩进需要多缩进一级
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)</code></pre><p>错误的写法</p>
<pre><code># 采用悬挂缩进时第一行不应该有参数
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 续行并没有被区分开，因此需要再缩进一级
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)</code></pre><p>对于延续行，4个空格的规则是可选使用的。</p>
<p>同样可行的例子:</p>
<pre><code># 悬挂缩进可以不采用4空格的缩进方法。
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)</code></pre><p>如果if语句太长，需要用多行书写，2个字符(例如,if)加上一个空格和一个左括号刚好是4空格的缩进，但这对多行条件语句的续行是没用的。因为这会和if语句中嵌套的其他的缩进的语句产生视觉上的冲突。这份PEP中并没有做出明确的说明应该怎样来区分条件语句和if语句中所嵌套的语句。以下几种方法都是可行的，但不仅仅只限于这几种方法：</p>
<pre><code># 不采用额外缩进
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# 增加一行注释，在编辑器中显示时能有所区分
# supporting syntax highlighting.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 在条件语句的续行增加一级缩进
if (this_is_one_thing
        and that_is_another_thing):
    do_something()</code></pre><p>多行结束右圆/方/花括号可以单独一行书写，和上一行的缩进对齐：</p>
<pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
    &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
    )</code></pre><p>也可以和多行开始的第一行的第一个字符对齐：</p>
<pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
    &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
)</code></pre><p>Tab还是空格？(Tab Or Space?)</p>
<p>推荐使用空格来进行缩进。</p>
<p>Tab应该只在现有代码已经使用tab进行缩进的情况下使用，以便和现有代码保持一致。</p>
<p>Python 3不允许tab和空格混合使用。</p>
<p>Python 2的代码若有tab和空格混合使用的情况，应该把tab全部转换为只有空格。</p>
<h3 id="2-2-每行最大长度-Maximum-Line-Length"><a href="#2-2-每行最大长度-Maximum-Line-Length" class="headerlink" title="2.2 每行最大长度(Maximum Line Length)"></a>2.2 每行最大长度(Maximum Line Length)</h3><p>将所有行都限制在79个字符长度以内。</p>
<p>对于连续大段的文字（比如文档字符串(docstring)或注释），其结构上的限制更少，这些行应该被限制在72个字符长度内。</p>
<p>限制编辑器的窗口宽度能让好几个文件同时打开在屏幕上显示，在使用代码评审(code review)工具时在两个相邻窗口显示两个版本的代码效果很好。</p>
<p>很多工具的默认自动换行会破坏代码的结构，使代码更难以理解。在窗口大小设置为80个字符的编辑器中，即使在换行时编辑器可能会在最后一列放置一个记号，为避免自动换行也需要限制每行字符长度。一些基于web的工具可能根本没有自动换行的功能。</p>
<p>一些团队会强烈希望行长度比79个字符更长。当代码仅仅只由一个团队维护时，可以达成一致让行长度增加到80到100字符(实际上最大行长是99字符)，注释和文档字符串仍然是以72字符换行。</p>
<p>Python标准库比较传统，将行长限制在79个字符以内（文档字符串/注释为72个字符）。</p>
<p>一种推荐的换行方式是利用Python圆括号、方括号和花括号中的隐式续行。长行可以通过在括号内换行来分成多行。应该最好加上反斜杠来区别续行。</p>
<p>隐式续行</p>
<pre><code>a = (&apos;sdfaf&apos; 
    &apos;test&apos;)</code></pre><p>有时续行只能使用反斜杠。例如，较长的多个with语句不能采用隐式续行，只能接受反斜杠表示换行：</p>
<pre><code>with open(&apos;/path/to/some/file/you/want/to/read&apos;) as file_1, \
     open(&apos;/path/to/some/file/being/written&apos;, &apos;w&apos;) as file_2:
    file_2.write(file_1.read())</code></pre><h3 id="2-3-二元运算符之前还是之后换行？-Should-a-line-break-before-or-after-a-binary-operator"><a href="#2-3-二元运算符之前还是之后换行？-Should-a-line-break-before-or-after-a-binary-operator" class="headerlink" title="2.3 二元运算符之前还是之后换行？(Should a line break before or after a binary operator?)"></a>2.3 二元运算符之前还是之后换行？(Should a line break before or after a binary operator?)</h3><p>长期以来一直推荐的风格是在二元运算符之后换行。但是这样会影响代码可读性，包括两个方面：一是运算符会分散在屏幕上的不同列上，二是每个运算符会留在前一行并远离操作数。所以，阅读代码的时候眼睛必须做更多的工作来确定哪些操作数被加，哪些操作数被减：</p>
<pre><code># 错误的例子：运算符远离操作数
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)</code></pre><p>为了解决这个可读性问题，数学家及其出版商遵循相反的规定。Donald Knuth在他的“电脑和排版”系列中解释了传统的规则：“尽管在段落中的公式总是在二元运算符之后换行，但显示公式时总是在二元运算符之前换行”。</p>
<pre><code># 正确的例子：更容易匹配运算符与操作数
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)</code></pre><p>在Python代码中，只要在统一项目中约定一致，就可以在二元运算符之前或之后换行。对于新编写的代码，建议使用Knuth的风格。</p>
<h3 id="2-4-空行-Blank-Line"><a href="#2-4-空行-Blank-Line" class="headerlink" title="2.4 空行(Blank Line)"></a>2.4 空行(Blank Line)</h3><p>使用2个空行来分隔最外层的函数(function)和类(class)定义。</p>
<p>使用1个空行来分隔类中的方法(method)定义。</p>
<p>可以使用额外的空行（尽量少）来分隔一组相关的函数。在一系列相关的仅占一行的函数之间，空行也可以被省略（比如一组虚函数定义）。</p>
<p>在函数内使用空行（尽量少）使代码逻辑更清晰。</p>
<p>例子：</p>
<pre><code>def func():


    class A(object):
        pass

    def func1():
        a = A()

    def func2():
        print(&apos;aaa&apos;)
        print(&apos;bbb&apos;)</code></pre><p>Python支持control-L（如:^L）换页符作为空格；许多工具将这些符号作为分页符，因此你可以使用这些符号来分页或者区分文件中的相关区域。注意，一些编辑器和基于web的代码预览器可能不会将control-L识别为分页符，而是显示成其他符号。</p>
<h3 id="2-5-源文件编码-Source-File-Encoding"><a href="#2-5-源文件编码-Source-File-Encoding" class="headerlink" title="2.5 源文件编码(Source File Encoding)"></a>2.5 源文件编码(Source File Encoding)</h3><p>Python核心发行版中的代码应该一直使用UTF-8（Python 2中使用ASCII）。</p>
<p>使用ASCII（Python 2）或者UTF-8（Python 3）的文件不应该添加编码声明。</p>
<p>在标准库中，只有用作测试目的，或者注释或文档字符串需要提及作者名字而不得不使用非ASCII字符时，才能使用非默认的编码。否则，在字符串文字中包括非ASCII数据时，推荐使用\x, \u, \U或\N等转义符。</p>
<p>对于Python 3.0及其以后的版本中，标准库遵循以下原则（参见PEP 3131）：Python标准库中的所有标识符都必须只采用ASCII编码的标识符，在可行的条件下也应当使用英文词（很多情况下，使用的缩写和技术术语词都不是英文）。此外，字符串文字和注释应该只包括ASCII编码。只有两种例外：</p>
<p>(a) 测试情况下为了测试非ASCII编码的特性</p>
<p>(b) 作者名字。作者名字不是由拉丁字母组成的也必须提供一个拉丁音译名。</p>
<p>鼓励具有全球受众的开放源码项目采用类似的原则。</p>
<h3 id="2-6-模块引用-Imports"><a href="#2-6-模块引用-Imports" class="headerlink" title="2.6 模块引用(Imports)"></a>2.6 模块引用(Imports)</h3><p>Imports应该分行写，而不是都写在一行，例如：</p>
<pre><code># 分开写
import os
import sys

# 不要像下面一样写在一行
import sys, os</code></pre><p>这样写也是可以的：</p>
<pre><code>from subprocess import Popen, PIPE</code></pre><p>Imports应该写在代码文件的开头，位于模块(module)注释和文档字符串(docstring)之后，模块全局变量(globals)和常量(constants)声明之前。</p>
<p>Imports应该按照下面的顺序分组来写：</p>
<ol>
<li>标准库imports</li>
<li>相关第三方imports</li>
<li>本地应用/库的特定imports</li>
</ol>
<p>如：</p>
<pre><code>import re
from lxml import etree
from ak_spider.common.mongo_models import *
from ak_spider.settings import CAPTCHA_SERVER, AK_PROXY_SERVER, logger</code></pre><p>不同组的imports之前用空格隔开。</p>
<p>推荐使用绝对(absolute)imports，因为这样通常更易读，在import系统没有正确配置（比如中的路径以sys.path结束）的情况下，也会有更好的表现（或者至少会给出错误信息）：</p>
<pre><code>import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example</code></pre><p>然而，除了绝对imports，显式的相对imports也是一种可以接受的替代方式。特别是当处理复杂的包布局(package layouts)时，采用绝对imports会显得啰嗦。</p>
<pre><code>from . import sibling
from .sibling import example</code></pre><p>标准库代码应当一直使用绝对imports，避免复杂的包布局。</p>
<p>隐式的相对imports应该永不使用，并且Python 3中已经被去掉了</p>
<p>当从一个包括类的模块中import一个类时，通常可以这样写：</p>
<pre><code>from myclass import MyClass
from foo.bar.yourclass import YourClass</code></pre><p>如果和本地命名的拼写产生了冲突，应当直接import模块：</p>
<pre><code>import myclass
import foo.bar.yourclass</code></pre><p>然后使用”myclass.MyClass”和”foo.bar.yourclass.YourClass”。</p>
<p>避免使用通配符imports(from <module> import *)，因为会造成在当前命名空间出现的命名含义不清晰，给读者和许多自动化工具造成困扰。有一个可以正当使用通配符import的情形，即将一个内部接口重新发布成公共API的一部分（比如，使用备选的加速模块中的定义去覆盖纯Python实现的接口，预先无法知晓具体哪些定义将被覆盖）。</p>
<p>当使用这种方式重新发布命名时，指南后面关于公共和内部接口的部分仍然适用。</p>
<h3 id="2-7-模块级的双下划线命名-Module-level-dunder-names"><a href="#2-7-模块级的双下划线命名-Module-level-dunder-names" class="headerlink" title="2.7 模块级的双下划线命名(Module level dunder names)"></a>2.7 模块级的双下划线命名(Module level dunder names)</h3><p>模块中的“双下滑线”（变量名以两个下划线开头，两个下划线结尾）变量，比如<strong>all</strong>，<strong>author，</strong>version__等，应该写在文档字符串(docstring)之后，除了form <strong>future</strong>引用(imports)的任何其它类型的引用语句之前。Python要求模块中<strong>future</strong>的导入必须出现在除文档字符串(docstring)之外的任何其他代码之前。</p>
<p>例如：</p>
<pre><code>&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
__version__ = &apos;0.1&apos;
__author__ = &apos;Cardinal Biggles&apos;

import os
import sys</code></pre><h2 id="3-字符串引用-String-Quotes"><a href="#3-字符串引用-String-Quotes" class="headerlink" title="3 字符串引用(String Quotes)"></a>3 字符串引用(String Quotes)</h2><p>在Python中表示字符串时，不管用单引号还是双引号都是一样的。但是不推荐将这两种方式看作一样并且混用。最好选择一种规则并坚持使用。当字符串中包含单引号时，采用双引号来表示字符串，反之也是一样，这样可以避免使用反斜杠，代码也更易读。</p>
<p>对于三引号表示的字符串，使用双引号字符来表示(即用”””而不是’’’)。</p>
<h2 id="4-表达式和语句中的空格-Whitespace-In-Expressions-And-Statements"><a href="#4-表达式和语句中的空格-Whitespace-In-Expressions-And-Statements" class="headerlink" title="4 表达式和语句中的空格(Whitespace In Expressions And Statements)"></a>4 表达式和语句中的空格(Whitespace In Expressions And Statements)</h2><h3 id="4-1-一些痛点-Pet-Peeves"><a href="#4-1-一些痛点-Pet-Peeves" class="headerlink" title="4.1 一些痛点(Pet Peeves)"></a>4.1 一些痛点(Pet Peeves)</h3><p>在下列情形中避免使用过多的空白：</p>
<p>方括号，圆括号和花括号之后：</p>
<pre><code>#正确的例子:
spam(ham[1], {eggs: 2})

#错误的例子：
spam( ham[ 1 ], { eggs: 2 } )</code></pre><p>逗号，分号或冒号之前：</p>
<pre><code>#正确的例子:
if x == 4: print x, y; x, y = y, x

#错误的例子:
if x == 4 : print x , y ; x , y = y , x</code></pre><p>不过，在切片操作时，冒号和二元运算符是一样的，应该在其左右两边保留相同数量的空格（就像对待优先级最低的运算符一样）。在扩展切片操作中，所有冒号的左右两边空格数都应该相等。不过也有例外，当切片操作中的参数被省略时，应该也忽略空格。</p>
<pre><code>#正确的例子:
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]

#错误的例子:
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]</code></pre><p>在调用函数时传递参数list的括号之前：</p>
<pre><code>#正确的例子:
spam(1)

#错误的例子:
pam (1)</code></pre><p>在索引和切片操作的左括号之前：</p>
<pre><code>#正确的例子:
dct[&apos;key&apos;] = lst[index]

#错误的例子:
dct [&apos;key&apos;] = lst [index]</code></pre><p>赋值(或其他)运算符周围使用多个空格来和其他语句对齐：</p>
<pre><code>#正确的例子:
x = 1
y = 2
long_variable = 3

#错误的例子:
x             = 1
y             = 2
long_variable = 3</code></pre><h3 id="4-2-其他建议-Other-Recommendations"><a href="#4-2-其他建议-Other-Recommendations" class="headerlink" title="4.2 其他建议(Other Recommendations)"></a>4.2 其他建议(Other Recommendations)</h3><p>避免任何行末的空格。因为它通常是不可见的，它可能会令人困惑：例如反斜杠后跟空格和换行符不会作为续行标记。一些编辑器会自动去除行末空格，许多项目（如CPython本身）都有提交前的预处理钩子来自动去除行末空格。</p>
<p>在二元运算符的两边都使用一个空格：赋值运算符(=)，增量赋值运算符(+=, -= etc.)，比较运算符(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算符(and, or, not)。</p>
<p>如果使用了优先级不同的运算符，则在优先级较低的操作符周围增加空白。请你自行判断，不过永远不要用超过1个空格，永远保持二元运算符两侧的空白数量一样。</p>
<pre><code>#正确的例子:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)

#错误的例子:
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)    </code></pre><p>使用=符号来表示关键字参数或参数默认值时，不要在其周围使用空格。</p>
<pre><code>#正确的例子:
def complex(real, imag=0.0):
return magic(r=real, i=imag)

#错误的例子:
def complex(real, imag = 0.0):
return magic(r = real, i = imag)</code></pre><p>函数注解中的:也遵循一般的:加空格的规则，在-&gt;两侧各使用一个空格。</p>
<pre><code>#正确的例子:
def munge(input: AnyStr): ...
def munge() -&gt; AnyStr: ...

#错误的例子:
def munge(input:AnyStr): ...
def munge()-&gt;PosInt: ...</code></pre><p>在组合使用函数注解和参数默认值时，需要在=两侧各使用一个空格（只有当这个参数既有函数注解，又有默认值的时候）。</p>
<pre><code>#正确的例子:
def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...

#错误的例子:
def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...</code></pre><p>复合语句（即将多行语句写在一行）一般是不鼓励使用的。</p>
<pre><code>#正确的例子:
if foo == &apos;blah&apos;:
do_blah_thing()
do_one()
do_two()
do_three()

#最好不要这样:
if foo == &apos;blah&apos;: do_blah_thing()
do_one(); do_two(); do_three()</code></pre><p>有时也可以将短小的if/for/while中的语句写在一行，但对于有多个分句的语句永远不要这样做。也要避免将多行都写在一起。</p>
<pre><code>#最好不要这样：
if foo == &apos;blah&apos;: do_blah_thing()
for x in lst: total += x
while t &lt; 10: t = delay()

#绝对不要这样：
if foo == &apos;blah&apos;: do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
list, like, this)

if foo == &apos;blah&apos;: one(); two(); three()</code></pre><h2 id="5-何时在末尾加逗号-When-to-use-trailing-commas"><a href="#5-何时在末尾加逗号-When-to-use-trailing-commas" class="headerlink" title="5 何时在末尾加逗号(When to use trailing commas)"></a>5 何时在末尾加逗号(When to use trailing commas)</h2><p>末尾逗号通常是可选的，除非在定义单元素元组(tuple)时是必需的（而且在Python 2中，它们具有print语句的语义）。为了清楚起见，建议使用括号（技术上来说是冗余的）括起来。</p>
<pre><code>#正确的例子:
FILES = (&apos;setup.cfg&apos;,)

#也正确，但令人困惑:
FILES = &apos;setup.cfg&apos;,</code></pre><p>当使用版本控制系统时，在将来有可能扩展的列表末尾添加冗余的逗号是有好处的。具体的做法是将每一个元素写在单独的一行，并在行尾添加逗号，右括号单独占一行。但是，与有括号在同一行的末尾元素后面加逗号是没有意义的（上述的单元素元组除外）。</p>
<pre><code>#正确的例子:
FILES = [
    &apos;setup.cfg&apos;,
    &apos;tox.ini&apos;,
    ]
initialize(FILES,
           error=True,
           )

#错误的例子:
FILES = [&apos;setup.cfg&apos;, &apos;tox.ini&apos;,]
initialize(FILES, error=True,)</code></pre><h2 id="6-注释-Comments"><a href="#6-注释-Comments" class="headerlink" title="6 注释(Comments)"></a>6 注释(Comments)</h2><p>和代码矛盾的注释还不如没有。当代码有改动时，一定要优先更改注释使其保持最新。</p>
<p>注释应该是完整的多个句子。如果注释是一个短语或一个句子，其首字母应该大写，除非开头是一个以小写字母开头的标识符（永远不要更改标识符的大小写）。</p>
<p>如果注释很短，结束的句号可以被忽略。块注释通常由一段或几段完整的句子组成，每个句子都应该以句号结束。</p>
<p>你应该在句尾的句号后再加上2个空格。</p>
<p>使用英文写作，参考Strunk和White的《The Elements of Style》</p>
<p>来自非英语国家的Python程序员们，请使用英文来写注释，除非你120%确定你的代码永远不会被不懂你所用语言的人阅读到。</p>
<h3 id="6-1-块注释（Block-Comments）"><a href="#6-1-块注释（Block-Comments）" class="headerlink" title="6.1 块注释（Block Comments）"></a>6.1 块注释（Block Comments）</h3><p>块注释一般写在对应代码之前，并且和对应代码有同样的缩进级别。块注释的每一行都应该以#和一个空格开头（除非该文本是在注释内缩进对齐的）。</p>
<p>块注释中的段落应该用只含有单个#的一行隔开。</p>
<h3 id="6-2-行内注释（Inline-Comments）"><a href="#6-2-行内注释（Inline-Comments）" class="headerlink" title="6.2 行内注释（Inline Comments）"></a>6.2 行内注释（Inline Comments）</h3><p>尽量少用行内注释。</p>
<p>行内注释是和代码语句写在一行内的注释。行内注释应该至少和代码语句之间有两个空格的间隔，并且以#和一个空格开始。</p>
<p>行内注释通常不是必要的，在代码含义很明显时甚至会让人分心。请不要这样做：</p>
<pre><code>x = x + 1                 # x自加</code></pre><p>但这样做是有用的：</p>
<pre><code>x = x + 1                 # 边界补偿</code></pre><h3 id="6-3-文档字符串-Documentation-Strings"><a href="#6-3-文档字符串-Documentation-Strings" class="headerlink" title="6.3 文档字符串(Documentation Strings)"></a>6.3 文档字符串(Documentation Strings)</h3><p>要知道如何写出好的文档字符串（docstring），请参考PEP 257</p>
<p>所有的公共模块，函数，类和方法都应该有文档字符串。对于非公共方法，文档字符串不是必要的，但你应该留有注释说明该方法的功能，该注释应当出现在def的下一行。</p>
<p>PEP 257描述了好的文档字符应该遵循的规则。其中最重要的是，多行文档字符串以单行”””结尾，不能有其他字符，例如：</p>
<pre><code>&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;</code></pre><p>对于仅有一行的文档字符串，结尾处的”””应该也写在这一行。</p>
<h2 id="7-命名约定（Naming-Conventions）"><a href="#7-命名约定（Naming-Conventions）" class="headerlink" title="7 命名约定（Naming Conventions）"></a>7 命名约定（Naming Conventions）</h2><p>Python标准库的命名约定有一些混乱，因此我们永远都无法保持一致。但如今仍然存在一些推荐的命名标准。新的模块和包（包括第三方框架）应该采用这些标准，但若是已经存在的包有另一套风格的话，还是应当与原有的风格保持内部一致。</p>
<h3 id="7-1-首要原则（Overriding-Principle）"><a href="#7-1-首要原则（Overriding-Principle）" class="headerlink" title="7.1 首要原则（Overriding Principle）"></a>7.1 首要原则（Overriding Principle）</h3><p>对于用户可见的公共部分API，其命名应当表达出功能用途而不是其具体的实现细节。</p>
<h3 id="7-2-描述：命名风格（Descriptive-Naming-Styles）"><a href="#7-2-描述：命名风格（Descriptive-Naming-Styles）" class="headerlink" title="7.2 描述：命名风格（Descriptive: Naming Styles）"></a>7.2 描述：命名风格（Descriptive: Naming Styles）</h3><p>存在很多不同的命名风格，最好能够独立地从命名对象的用途认出采用了哪种命名风格。</p>
<p>通常区分以下命名样式：</p>
<ul>
<li>b (单个小写字母)</li>
<li>B (单个大写字母)</li>
<li>lowercase(小写)</li>
<li>lower_case_with_underscores(带下划线小写)</li>
<li>UPPERCASE(大写)</li>
<li>UPPER_CASE_WITH_UNDERSCORES(带下划线大写)</li>
<li>CapitalizedWords (也叫做CapWords或者CamelCase – 因为单词首字母大写看起来很像驼峰)。也被称作StudlyCaps。注意：当CapWords里包含缩写时，将缩写部分的字母都大写。HTTPServerError比HttpServerError要好。</li>
<li>mixedCase (注意：和CapitalizedWords不同在于其首字母小写！)</li>
<li>Capitalized_Words_With_Underscores (这种风格超丑！)</li>
</ul>
<p>也有风格使用简短唯一的前缀来表示一组相关的命名。这在Python中并不常见，但为了完整起见这里也捎带提一下。比如，os.stat()函数返回一个tuple，其中的元素名原本为st_mode,st-size,st_mtime等等。（这样做是为了强调和POSIX系统调用结构之间的关系，可以让程序员更熟悉。）</p>
<p>X11库中的公共函数名都以X开头。在Python中这样的风格一般被认为是不必要的，因为属性和方法名之前已经有了对象名的前缀，而函数名前也有了模块名的前缀。</p>
<p>此外，要区别以下划线开始或结尾的特殊形式（可以和其它的规则结合起来）：</p>
<p>_single_leading_underscore: 以单个下划线开头是”内部使用”的弱标志。 比如， from M import *不会import下划线开头的对象。</p>
<p>single_trailing_underscore_: 以单个下划线结尾用来避免和Python关键词产生冲突，例如:</p>
<pre><code>Tkinter.Toplevel(master, class_=&apos;ClassName&apos;)</code></pre><p><strong>double_leading_underscore: 以双下划线开头的风格命名类属性表示触发命名修饰（在FooBar类中，</strong>boo命名会被修饰成_FooBar__boo;）。</p>
<h3 id="7-3-规范：命名约定-Prescriptive-Naming-Conventions"><a href="#7-3-规范：命名约定-Prescriptive-Naming-Conventions" class="headerlink" title="7.3 规范：命名约定(Prescriptive: Naming Conventions)"></a>7.3 规范：命名约定(Prescriptive: Naming Conventions)</h3><h4 id="7-3-1-需要避免的命名-Names-To-Avoid"><a href="#7-3-1-需要避免的命名-Names-To-Avoid" class="headerlink" title="7.3.1 需要避免的命名(Names To Avoid)"></a>7.3.1 需要避免的命名(Names To Avoid)</h4><p>不要使用字符’l’（L的小写的字母），’O’（o大写的字母），或者’I’（i的大写的字母）来作为单个字符的变量名。</p>
<p>在一些字体中，这些字符和数字1和0无法区别开来。比如，当想使用’l’时，使用’L’代替。</p>
<h4 id="7-3-2-ASCII兼容性-ASCII-Compatibility"><a href="#7-3-2-ASCII兼容性-ASCII-Compatibility" class="headerlink" title="7.3.2 ASCII兼容性(ASCII Compatibility)"></a>7.3.2 ASCII兼容性(ASCII Compatibility)</h4><p>标准库中使用的标识符必须与ASCII兼容(参见PEP 3131中的<a href="https://www.python.org/dev/peps/pep-3131/#policy-specification" target="_blank" rel="noopener">policy</a>这一节) 。</p>
<h4 id="7-3-3-包和模块命名-Package-And-Module-Names"><a href="#7-3-3-包和模块命名-Package-And-Module-Names" class="headerlink" title="7.3.3 包和模块命名(Package And Module Names)"></a>7.3.3 包和模块命名(Package And Module Names)</h4><p>模块命名应短小，且为全小写。若下划线能提高可读性，也可以在模块名中使用。Python包命名也应该短小，且为全小写，但不应使用下划线。</p>
<p>当使用C或C++写的扩展模块有相应的Python模块提供更高级的接口时（比如，更加面向对象），C/C++模块名以下划线开头（例如，_sociket）</p>
<h4 id="7-3-4-类命名-Class-Names"><a href="#7-3-4-类命名-Class-Names" class="headerlink" title="7.3.4 类命名(Class Names)"></a>7.3.4 类命名(Class Names)</h4><p>类命名应该使用驼峰（CapWords）的命名约定。</p>
<p>当接口已有文档说明且主要是被用作调用时，也可以使用函数的命名约定。</p>
<p>注意对于内建命名(builtin names)有一个特殊的约定：大部分内建名都是一个单词（或者两个一起使用的单词），驼峰(CapWords)的约定只对异常命名和内建常量使用。</p>
<h4 id="7-3-5-类型变量命名-Type-variable-names"><a href="#7-3-5-类型变量命名-Type-variable-names" class="headerlink" title="7.3.5 类型变量命名(Type variable names)"></a>7.3.5 类型变量命名(Type variable names)</h4><p>PEP 484中引入的类型变量名称通常应使用简短的驼峰命名: T，AnyStr，Num。 建议将后缀_co或_contra添加到用于声明相应的协变(covariant)和逆变(contravariant)的行为。例如：</p>
<pre><code>from typing import TypeVar

VT_co = TypeVar(&apos;VT_co&apos;, covariant=True)
KT_contra = TypeVar(&apos;KT_contra&apos;, contravariant=True)</code></pre><h4 id="7-3-6-异常命名-Exception-Names"><a href="#7-3-6-异常命名-Exception-Names" class="headerlink" title="7.3.6 异常命名(Exception Names)"></a>7.3.6 异常命名(Exception Names)</h4><p>由于异常实际上也是类，因此类命名约定也适用与异常。不同的是，如果异常实际上是抛出错误的话，异常名前应该加上”Error”的前缀。</p>
<h4 id="7-3-7-全局变量命名-Global-Variable-Names"><a href="#7-3-7-全局变量命名-Global-Variable-Names" class="headerlink" title="7.3.7 全局变量命名(Global Variable Names)"></a>7.3.7 全局变量命名(Global Variable Names)</h4><p>（在此之前，我们先假定这些变量都仅在同一个模块内使用。）这些约定同样也适用于函数命名。</p>
<p>对于引用方式设计为from M import *的模块，应该使用<strong>all</strong>机制来避免import全局变量，或者采用下划线前缀的旧约定来命名全局变量，从而表明这些变量是“模块非公开的”。</p>
<h4 id="7-3-8-函数命名-Function-Names"><a href="#7-3-8-函数命名-Function-Names" class="headerlink" title="7.3.8 函数命名(Function Names)"></a>7.3.8 函数命名(Function Names)</h4><p>函数命名应该都是小写，必要时使用下划线来提高可读性。</p>
<p>只有当已有代码风格已经是混合大小写时（比如threading.py），为了保留向后兼容性才使用混合大小写。</p>
<h4 id="7-3-9-函数和方法参数-Function-And-Method-Arguments"><a href="#7-3-9-函数和方法参数-Function-And-Method-Arguments" class="headerlink" title="7.3.9 函数和方法参数(Function And Method Arguments)"></a>7.3.9 函数和方法参数(Function And Method Arguments)</h4><p>实例方法的第一参数永远都是self。</p>
<p>类方法的第一个参数永远都是cls。</p>
<p>在函数参数名和保留关键字冲突时，相对于使用缩写或拼写简化，使用以下划线结尾的命名一般更好。比如，class_比clss更好。（或许使用同义词避免这样的冲突是更好的方式。）</p>
<h4 id="7-3-10-方法命名和实例变量-Method-Names-And-Instance-Variables"><a href="#7-3-10-方法命名和实例变量-Method-Names-And-Instance-Variables" class="headerlink" title="7.3.10 方法命名和实例变量(Method Names And Instance Variables)"></a>7.3.10 方法命名和实例变量(Method Names And Instance Variables)</h4><p>使用函数命名的规则：小写单词，必要时使用下划线分开以提高可读性。</p>
<p>仅对于非公开方法和变量命名在开头使用一个下划线。</p>
<p>避免和子类的命名冲突，使用两个下划线开头来触发Python的命名修饰机制。</p>
<p>Python类名的命名修饰规则：如果类Foo有一个属性叫<strong>a，不能使用Foo.</strong>a的方式访问该变量。（有用户可能仍然坚持使用Foo._Foo__a的方法访问。）一般来说，两个下划线开头的命名方法仅用于避免与设计为子类的类中的属性名冲突。</p>
<h4 id="7-3-11-常量-Constants"><a href="#7-3-11-常量-Constants" class="headerlink" title="7.3.11 常量(Constants)"></a>7.3.11 常量(Constants)</h4><p>常量通常是在模块级别定义的，使用全部大写并用下划线将单词分开。如：MAX_OVERFLOW和TOTAL 。</p>
<h4 id="7-3-12-继承的设计-Designing-For-Inheritance"><a href="#7-3-12-继承的设计-Designing-For-Inheritance" class="headerlink" title="7.3.12 继承的设计(Designing For Inheritance)"></a>7.3.12 继承的设计(Designing For Inheritance)</h4><p>记得永远区别类的方法和实例变量（属性）应该是公开的还是非公开的。如果有疑虑的话，请选择非公开的；因为之后将非公开属性变为公开属性要容易些。</p>
<p>公开属性是那些你希望和你定义的类无关的客户来使用的，并且确保不会出现向后不兼容的问题。非公开属性是那些不希望被第三方使用的部分，你可以不用保证非公开属性不会变化或被移除。</p>
<p>我们在这里没有使用“私有（private）”这个词，因为在Python里没有什么属性是真正私有的（这样设计省略了大量不必要的工作）。</p>
<p>另一类属性属于子类API的一部分（在其他语言中经常被称为”protected”）。一些类是为继承设计的，要么扩展要么修改类的部分行为。当设计这样的类时，需要谨慎明确地决定哪些属性是公开的，哪些属于子类API，哪些真的只会被你的基类调用。</p>
<p>请记住以上几点，下面是Python风格的指南：</p>
<ul>
<li>公开属性不应该有开头下划线。</li>
<li>如果公开属性的名字和保留关键字有冲突，在你的属性名尾部加上一个下划线。这比采用缩写和简写更好。（然而，和这条规则冲突的是，‘cls’对任何变量和参数来说都是一个更好地拼写，因为大家都知道这表示class，特别是在类方法的第一个参数里。）</li>
<li>对于简单的公共数据属性，最后仅公开属性名字，不要公开复杂的调用或设值方法。请记住，如果你发现一个简单的数据属性需要增加功能行为时，Python为功能增强提供了一个简单的途径。这种情况下，使用Properties注解将功能实现隐藏在简单数据属性访问语法之后。注意 1：Properties注解仅仅对新风格类有用。<br>注意 2：尽量保证功能行为没有副作用，尽管缓存这种副作用看上去并没有什么大问题。<br>注意 3: 对计算量大的运算避免试用properties；属性的注解会让调用者相信访问的运算量是相对较小的。</li>
<li>如果你的类将被子类继承的话，你有一些属性并不想让子类访问，考虑将他们命名为两个下划线开头并且结尾处没有下划线。这样会触发Python命名修饰算法，类名会被修饰添加到属性名中。这样可以避免属性命名冲突，以免子类会不经意间包含相同的命名。注意 1：注意命名修饰仅仅是简单地将类名加入到修饰名中，所以如果子类有相同的类名合属性名，你可能仍然会遇到命名冲突问题。<br>注意 2：命名修饰可以有特定用途，比如在调试时，__getattr__()比较不方便。然而命名修饰算法的可以很好地记录，并且容意手动执行。<br>注意 3：不是所有人都喜欢命名修饰。需要试着去平衡避免偶然命名冲突的需求和高级调用者使用的潜在可能性。</li>
</ul>
<h3 id="7-4-公开和内部接口-Public-And-Internal-Interfaces"><a href="#7-4-公开和内部接口-Public-And-Internal-Interfaces" class="headerlink" title="7.4 公开和内部接口(Public And Internal Interfaces)"></a>7.4 公开和内部接口(Public And Internal Interfaces)</h3><p>任何向后兼容性保证仅对公开接口适用。相应地，用户能够清楚分辨公开接口和内部接口是很重要的。</p>
<p>文档化的接口被认为是公开的，除非文档中明确申明了它们是临时的或者内部接口，不保证向后兼容性。所有文档中未提到的接口应该被认为是内部的。</p>
<p>为了更好审视公开接口和内部接口，模块应该在<strong>all属性中明确申明公开API是哪些。将</strong>all__设为空list表示该模块中没有公开API。</p>
<p>即使正确设置了__all属性，内部接口（包，模块，类，函数，属性或其他命名）也应该以一个下划线开头。</p>
<p>如果接口的任一一个命名空间（包，模块或类）是内部的，那么该接口也应该是内部的</p>
<p>引用的命名应该永远被认为是实现细节。其他模块不应当依赖这些非直接访问的引用命名，除非它们在文档中明确地被写为模块的API，例如os.path或者包的<strong>init</strong>模块，那些从子模块展现的功能。</p>
<h2 id="8-编程建议-Programming-Recommendations"><a href="#8-编程建议-Programming-Recommendations" class="headerlink" title="8 编程建议(Programming Recommendations)"></a>8 编程建议(Programming Recommendations)</h2><p>1 代码应该以不影响其他Python实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。</p>
<p>例如，不要依赖于 CPython 在字符串拼接时的优化实现，像这种语句形式a += b和a = a + b。即使是 CPython（仅对某些类型起作用） 这种优化也是脆弱的，不是在所有的实现中都不使用引用计数。在库中性能敏感的部分，用’’.join形式来代替。这会确保在所有不同的实现中字符串拼接是线性时间的。</p>
<p>2 与单例作比较，像None应该用is或is not，从不使用==操作符。</p>
<p>同样的，当心if x is not None这样的写法，你是不知真的要判断x不是None。例如，测试一个默认值为None的变量或参数是否设置成了其它值，其它值有可能是某种特殊类型（如容器），这种特殊类型在逻辑运算时其值会被当作Flase来看待。</p>
<p>用is not操作符而不是not … is。虽然这两个表达式是功能相同的，前一个是更可读的，是首选。</p>
<p>推荐的写法:</p>
<pre><code>if foo is not None:</code></pre><p>不推荐的写法:</p>
<pre><code>if not foo is None:</code></pre><p>3 用富比较实现排序操作的时候，最好实现所有六个比较操作符（ __eq__ 、 __ne__ 、 __lt__ , __le__ , __gt__ , __ge__），而不是依靠其他代码来进行特定比较。</p>
<p>为了最大限度的减少工作量，functools.total_ordering()装饰器提供了一个工具去生成缺少的比较方法。</p>
<p>PEP 207 说明了 Python 假定的所有反射规则。因此，解释器可能使用y &gt; x替换x &lt; y，使用y &gt;= x替换x &lt;= y，也可能交换x == y和x != y的操作数。sort()和min()操作肯定会使用&lt;操作符，max()函数肯定会使用&gt;操作符。当然，最好是六个操作符都实现，以便在其他情况下不会出现混淆。</p>
<p>4 始终使用def语句来代替直接绑定了一个lambda表达式的赋值语句。</p>
<p>推荐的写法:</p>
<pre><code>def f(x): return 2*x</code></pre><p>不推荐的写法:</p>
<pre><code>f = lambda x: 2*x</code></pre><p>第一个表单意味着生成的函数对象的名称是’f’而不是通用的’<lambda>‘。通常这对异常追踪和字符串表述是更有用的。使用赋值语句消除了使用lambda表达式可以提供，而一个显式的def语句不能提供的唯一好处，如，lambda能镶嵌在一个很长的表达式里。</p>
<p>5 异常类应派生自Exception而不是BaseException。直接继承BaseException是为Exception保留的，从BaseException继承并捕获异常这种做法几乎总是错的。</p>
<p>设计异常的层次结构，应基于那些可能出现异常的代码，而不是引发异常的位置。编码的时候，以回答“出了什么问题？”为目标，而不是仅仅指出“这里出现了问题”（见 PEP 3151 一个内建异常结构层次的例子）。</p>
<p>类的命名约定适用于异常，如果异常类是一个错误，你应该给异常类加一个后缀Error。用于非本地流程控制或者其他形式的信号的非错误异常不需要一个特殊的后缀。</p>
<p>6 适当的使用异常链。在 Python 3 里，应该使用raise X from Y来指示显式替换，而不会丢失原始的追溯。</p>
<p>当有意替换一个内部的异常时（在 Python 2 用raise X，Python 3.3+ 用raise X from None），请确保将相关详细信息转移到新异常中（例如，将KeyError转换为AttributeError时保留属性名称，或将原始异常的文本嵌入到新的异常消息中）。</p>
<p>7 在 Python 2 里抛出异常时，用raise ValueError(‘message’)代替旧式的raise ValueError, ‘message’。</p>
<p>在 Python 3 之后的语法里，旧式的异常抛出方式是非法的。</p>
<p>使用括号形式的异常意味着，当你传给异常的参数过长或者包含字符串格式化时，你就不需要使用续行符了，这要感谢括号！</p>
<p>8 捕获异常时，尽可能使用明确的异常，而不是用一个空的except:语句。</p>
<p>例如，用：</p>
<pre><code>try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None</code></pre><p>一个空的except:语句将会捕获到SystemExit和KeyboardInterrupt异常，很难区分程序的中断到底是Ctrl+C还是其他问题引起的。如果你想捕获程序的所有错误，使用except Exception:(空except:等同于except BaseException)。</p>
<p>一个好的经验是限制使用空except语句，除了这两种情况：</p>
<ul>
<li>如果异常处理程序会打印出或者记录回溯信息；至少用户意识到错误的存在。</li>
<li>如果代码需要做一些清理工作，但后面用raise向上抛出异常。try .. finally是处理这种情况更好的方式。</li>
</ul>
<p>9 绑定异常给一个名字时，最好使用 Python 2.6 里添加的明确的名字绑定语法：</p>
<pre><code>try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))</code></pre><p>Python 3 只支持这种语法，避免与基于逗号的旧式语法产生二义性。</p>
<p>10 捕获操作系统错误时，最好使用 Python 3.3 里引进的明确的异常结构层次，而不是内省的errno值。</p>
<p>11 另外，对于所有try / except子句，将try子句限制为必需的绝对最小代码量。同样，这样可以避免屏蔽错误。</p>
<p>推荐的写法：</p>
<pre><code>try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)</code></pre><p>不推荐的写法：</p>
<pre><code>try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)</code></pre><p>12 当某个资源仅被特定代码段使用，用with语句确保其在使用后被立即干净的清除了，try/finally也是也接受的。</p>
<p>13 当它们做一些除了获取和释放资源之外的事的时候，上下文管理器应该通过单独的函数或方法调用。例如：</p>
<p>推荐的写法:</p>
<pre><code>with conn.begin_transaction():
    do_stuff_in_transaction(conn)</code></pre><p>不推荐的写法：</p>
<pre><code>with conn:
    do_stuff_in_transaction(conn)</code></pre><p>第二个例子没有提供任何信息来表明<strong>enter</strong>和<strong>exit</strong>方法在完成一个事务后做了一些除了关闭连接以外的其它事。在这种情况下明确是很重要的。</p>
<p>14 坚持使用return语句。函数内的return语句都应该返回一个表达式，或者None。如果一个return语句返回一个表达式，另一个没有返回值的应该用return None清晰的说明，并且在一个函数的结尾应该明确使用一个return语句（如果有返回值的话）。</p>
<p>推荐的写法：</p>
<pre><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x &lt; 0:
        return None
    return math.sqrt(x)</code></pre><p>不推荐的写法：</p>
<pre><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)

def bar(x):
    if x &lt; 0:
        return
    return math.sqrt(x)</code></pre><p>15 用字符串方法代替字符串模块。</p>
<p>字符串方法总是快得多，并且与unicode字符串共享相同的API。如果需要与2.0以下的Python的向后兼容，则覆盖此规则。</p>
<p>16 用’’.startswith()和’’.endswith()代替字符串切片来检查前缀和后缀。</p>
<p>startswith()和endswith()是更简洁的，不容易出错的。例如：</p>
<pre><code>#推荐的写法：
if foo.startswith(&apos;bar&apos;):

#不推荐的写法：
if foo[:3] == &apos;bar&apos;:</code></pre><p>17 对象类型的比较应该始终使用isinstance()而不是直接比较。</p>
<pre><code>#推荐的写法：
if isinstance(obj, int):

#不推荐的写法：
if type(obj) is type(1):</code></pre><p>当比较一个对象是不是字符串时，记住它有可能也是一个 unicode 字符串！在 Python 2 里面，str和unicode有一个公共的基类叫basestring，因此你可以这样做：</p>
<pre><code>if isinstance(obj, basestring):</code></pre><p>注意，在 Python 3 里面，unicode和basestring已经不存在了（只有str），byte对象不再是字符串的一种（被一个整数序列替代）。</p>
<p>18 对于序列（字符串、列表、元组）来说，空的序列为False：</p>
<p>正确的写法：</p>
<pre><code>if not seq:
if seq:</code></pre><p>错误的写法：</p>
<pre><code>if len(seq):
if not len(seq):</code></pre><p>19 不要让字符串对尾随的空格有依赖。这样的尾随空格是视觉上无法区分的，一些编辑器（或者，reindent.py）会将其裁剪掉。</p>
<p>20 不要用==比较True和False。</p>
<pre><code>#推荐的写法：
if greeting:

#不推荐的写法：
if greeting == True:

#更加不推荐的写法：
if greeting is True:</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>
